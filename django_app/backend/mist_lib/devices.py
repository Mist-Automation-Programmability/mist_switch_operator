
import requests
import logging
import re
from .common import Common
import uuid

PORT_USAGE_NAME_PREFIX = "autogenerated_"
logging.basicConfig(level=logging.INFO)


class Devices(Common):

    #############
    # get list of switches on a site
    #############
    def get_devices(self, body):
        body = self.get_body(body)
        if not "site_id" in body:
            return {"status": 500, "data": {"message": "site_id missing"}}
        return self._get_devices(body)

    def _get_devices(self, body, retry=False):
        site_id = body["site_id"]
        try:
            logging.info(f"Site:{site_id}:Devices: In Process")
            extract = self.extractAuth(body)
            limit = 1000
            page = 1
            results = []
            total = 1
            while len(results) < int(total) and int(page) < 50:
                device_type = "switch"
                url = f"https://{extract['host']}/api/v1/sites/{site_id}/devices?type={device_type}&limit={limit}&page={page}"
                resp = requests.get(
                    url, headers=extract["headers"], cookies=extract["cookies"])
                results.extend(resp.json())
                total = resp.headers["X-Page-Total"]
                page += 1
            logging.info(f"Site:{site_id}:Devices: Done")
            return self._get_devices_vc(extract, body["site_id"], results)
        except:
            if retry:
                logging.error(f"Site:{site_id}:Devices: Error")
                return {"status": 500, "data": {"message": "Unable to retrieve the inventory"}}
            else:
                logging.warning(f"Site:{site_id}:Devices: Retry")
                return self._get_devices(body, True)

    def _get_devices_vc(self, extract, site_id, devices):
        data = []
        for device in devices:
            device_id = f"00000000-0000-0000-1000-{device['mac']}"
            disable_auto_config = device.get("disable_auto_config", False)
            try:
                logging.info(f"Device:{site_id}:VC: In Process")
                url = f"https://{extract['host']}/api/v1/sites/{site_id}/devices/{device_id}/vc"
                resp = requests.get(
                    url, headers=extract["headers"], cookies=extract["cookies"])
                tmp = resp.json()
                tmp["name"] = device["name"]
                tmp["disable_auto_config"] = disable_auto_config
                logging.info(f"Device:{device_id}:VC: Done")
                data.append(tmp)
            except:
                logging.error(f"Device:{device_id}:VC: Error")
                #return {"status": 500, "data": {"message": "Unable to retrieve information for device {0}".format(device_id)}}
        return {"status": 200, "data": {"total": len(data), "results": data}}


#############
# Get Device Settings
#############
# body: site_id, device_id, device_name, device_role, device_model


    def get_device_settings(self, body, device_models):
        body = self.get_body(body)
        if not "site_id" in body:
            return {"status": 500, "data": {"message": "site_id missing"}}
        if not "device_id" in body:
            return {"status": 500, "data": {"message": "device_id missing"}}
        extract = self.extractAuth(body)
        device_settings = self._get_device_settings(extract, body)
        device_stats = self._get_device_stats(extract, body)
        site_settings = self._get_site_template(extract, body)
        networks = self._generate_networks(site_settings, device_settings)
        if not "status" in device_settings and not "status" in site_settings:
            data = self._generate_device_settings(
                device_settings, site_settings, device_stats, device_models)
            return {"status": 200, "data": {"members": data["members"], "networks": networks, "ports": data["ports"], "site": site_settings, "device": device_settings}}

    def _generate_networks(self, site_config, device_config):
        networks = site_config.get("networks", {})
        device_networks = device_config.get("networks", {})
        for network in device_networks:
            networks[network] = device_networks[network]
        return networks

    def _get_device_settings(self, extract, body, retry=False):
        device_id = body["device_id"]
        device_config = {
            "networks": {},
            "port_usages": {},
            "port_config": {}
        }
        try:
            logging.info(f"Device:{device_id}:Settings: In Process")
            url = f"https://{body['host']}/api/v1/sites/{body['site_id']}/devices/{device_id}"
            resp = requests.get(
                url, headers=extract["headers"], cookies=extract["cookies"])
            device_setting = resp.json()
            device_config["ip_config"] = device_setting.get("ip_config", {})
            device_config["oob_ip_config"] = device_setting.get("oob_ip_config", {})
            device_config["other_ip_configs"] = device_setting.get("other_ip_configs", {})
            device_config["managed"] = device_setting.get("managed", False)
            device_config["networks"] = device_setting.get("networks", {})
            device_config["port_usages"] = device_setting.get("port_usages", {})
            device_config["port_config"] = device_setting.get("port_config", {})
            logging.info(f"Device:{device_id}:Settings: Done")
            return device_config
        except:
            if retry:
                logging.error(f"Device:{device_id}:Settings: Error")
                return {
                    "status": 500, 
                    "data": {"message": "Unable to retrieve the device settings"}
                    }
            else:
                logging.warning(f"Device:{device_id}:Settings: Retry")
                return self._get_device_settings(extract, body, True)

    def _get_device_stats(self, extract, body, retry=False):
        device_id = body["device_id"]
        try:
            logging.info(f"Device:{device_id}:Stats: In Process")
            url = f"https://{extract['host']}/api/v1/sites/{body['site_id']}/stats/devices/{device_id}"
            resp = requests.get(
                url, headers=extract["headers"], cookies=extract["cookies"])
            logging.info(f"Device:{device_id}:Stats: Done")
            return resp.json()
        except:
            if retry:
                logging.error(f"Device:{device_id}:Stats: Error")
                return {"status": 500, "data": {"message": f"Unable to retrieve information for device {body['device_id']}"}}
            else:
                logging.warning(f"Device:{device_id}:Stats: Retry")
                return self._get_device_stats(extract, body, True)

    def _get_site_template(self, extract, body, retry=False):
        site_id = body["site_id"]
        try:
            logging.info(f"Site:{site_id}:Settings: In Process")
            url = f"https://{body['host']}/api/v1/sites/{site_id}/setting/derived"
            resp = requests.get(
                url, headers=extract["headers"], cookies=extract["cookies"])
            site_setting = resp.json()
            logging.info(f"Site:{site_id}:Settings: Done")
            return self._parse_site_template(body, site_setting)
        except:
            print("Exception occurred", exc_info=True)
            if retry:
                logging.error(f"Site:{site_id}:Settings: Error")
                return {"status": 500, "data": {"message": "Unable to retrieve the site settings"}}
            else:
                logging.warning(f"Site:{site_id}:Settings: Retry")
                return self._get_site_template(extract, body, True)

    def _parse_site_template(self, body, site_setting):
        site_networks = site_setting.get("networks", {})
        site_port_usages = site_setting.get("port_usages", {})
        if "switch_matching" in site_setting:
            device_name = body.get("device_name","")
            device_role = body.get("device_role", "")
            device_model = body.get("device_model", "")
            site_port_config = {}
            if site_setting["switch_matching"].get("enable", False):
                rules = site_setting["switch_matching"].get("rules", {})

                for rule in rules:
                    match = True
                    for key in rule:
                        if key == "match_model":
                            if not device_model.startswith(rule[key]):
                                match = False
                        if key == "role_name":
                            if not device_role == rule[key]:
                                match = False
                        if key.startswith("match_name"):
                            sub = rule[key].replace(
                                "match_name[", "").replace("]", "").split(":")
                            start = sub[0]
                            end = sub[1]
                            if not device_name[start:end] == rule[key]:
                                match = False
                    if match and "port_config" in rule:
                        site_port_config = rule["port_config"]
                        break
            return {"port_config": site_port_config, "networks": site_networks, "port_usages": site_port_usages}
        else:
            return {"networks": {},  "networks": site_networks, "port_usages": site_port_usages}

    def _generate_device_settings(self, device_settings, site_settings, device_stats, device_models):
        data = {
            "members": [],
            "ports": {}
        }
        fpc = 0
        # Add information about each member of the VC (or the standalone)
        for member in device_stats["module_stat"]:
            tmp = {
                "mac": member["mac"] if "mac" in member else "None",
                "model": member["model"] if "model" in member else "None",
                "serial": member["serial"] if "serial" in member else "None",
                "vc_state": member["vc_state"] if "vc_state" in member else "None",
                "poe": member["poe"] if "poe" in member else "None",
                "fans": member["fans"] if "fans" in member else "None",
                "uptime": member["uptime"] if "uptime" in member else "None",
                "temperatures": member["temperatures"] if "temperatures" in member else "None",
                "vc_links": member["vc_links"] if "vc_links" in member else "None",
                "psus": member["psus"] if "psus" in member else "None",
                "vc_role": member["vs_role"] if "vs_role" in member else "None",
                "ports": [],
                "columns": {
                    "rj45": 0,
                    "sfp": 0
                }
            }

            # Generate the list of ports based on the HW model
            dev_list = list(dev_mod for dev_mod in device_models if dev_mod.get("model") == member["model"] or dev_mod.get("alias") == member["model"])
            if len(dev_list) == 0:
                logging.error(f"Unable to find model for device {member['model']}")
            else:
                if len(dev_list) > 1:
                    logging.warning(f"Got {len(dev_list)} models for device {member['model']}")
            
                dev = dev_list[0]
                dev_pics = dev.get('pic', {})
                for pic, interfaces in dev_pics.items():
                    interfaces_cleanse = interfaces.replace(" (uplink)", "")
                    interfaces_split = interfaces_cleanse.split(",")
                    i = 0
                    for int_def in interfaces_split:
                        int_type = int_def.split("/")[0].split("*")[0].replace(" ", "")
                        int_count = int(int_def.split("/")[0].split("*")[1])
                        if int_type.startswith("qsfp"):
                            int_type = "et"
                        elif int_type.startswith("sfp"):
                            int_type = "xe"
                        for int_num in range(i, int_count+i):
                            interface_name = f"{int_type}-{fpc}/{pic}/{int_num}"
                            tmp["ports"].append(interface_name)
                            data["ports"][interface_name] = {
                                "port": interface_name, "site": {}, "device": {}}
                        i += int_count
            data["members"].append(tmp)
            fpc += 1
        data = self._translate_mist_conf(data, site_settings, "site")
        data = self._translate_mist_conf(data, device_settings, "device")

        return data

    def _translate_mist_conf(self, data, config, scope):
        if config.get("port_config"):
            # for each port config (means ge-0/0/0) or ports range config (means ge-0-2/0-1/0-10)
            for port_config in config["port_config"]:
                # if port config (means ge-0/0/0)
                if re.match(r'^[a-z0-9]+-[0-9]+/[0-9]+/[0-9]+$', port_config):
                    fpc = int(port_config.split("-")[1].split("/")[0])
                    if not port_config in data["ports"]:
                        data["ports"][port_config] = {
                            "port": port_config, "site": {}, "device": {}}
                    data["ports"][port_config][scope] = config["port_config"][port_config]

                # else, it's a ports range config (means ge-0-1/0-2/0-10)
                else:
                    ae_uuid = uuid.uuid4()
                    if config["port_config"][port_config].get("aggregated", False):
                        config["port_config"][port_config]["ae_uuid"] = ae_uuid
                    port_config_split = port_config.split(",")
                    for port_config_item in port_config_split:
                        port_type = port_config_item.split("-", 1)[0]
                        fpc = port_config_item.split(
                            "-", 1)[1].split("/")[0].split("-")
                        pic = port_config_item.split(
                            "-", 1)[1].split("/")[1].split("-")
                        slot = port_config_item.split(
                            "-", 1)[1].split("/")[2].split("-")
                        for i in range(int(fpc[0]), int(fpc[-1])+1):
                            for j in range(int(pic[0]), int(pic[-1])+1):
                                for k in range(int(slot[0]), int(slot[-1])+1):
                                    interface = f"{port_type}-{i}/{j}/{k}".replace(" ", "")
                                    if not interface in data["ports"]:
                                        data["ports"][interface] = {
                                            "port": interface, "site": {}, "device": {}}
                                    data["ports"][interface][scope] = config["port_config"][port_config]

        return data

    #############
    # Update Device Settings
    #############
    def update_device_settings(self, body):
        body = self.get_body(body)
        if not "site_id" in body:
            return {"status": 500, "data": {"message": "site_id missing"}}
        if not "device_id" in body:
            return {"status": 500, "data": {"message": "device_id missing"}}
        if not "port_config" in body:
            return {"status": 500, "data": {"message": "port_config missing"}}
        return self._update_device_settings(body)

    def _update_device_settings(self, body):
        extract = self.extractAuth(body)
        # try:
        url = f"https://{body['host']}/api/v1/sites/{body['site_id']}/devices/{body['device_id']}"
        resp = requests.get(
            url, headers=extract["headers"], cookies=extract["cookies"])
        mist_device_settings = self._mutate_device_settings(body, resp.json())
        resp = requests.put(
            url, headers=extract["headers"], cookies=extract["cookies"], json=mist_device_settings)
        resp = resp.json()

        return {"status": 200, "data": {"result": resp}}
        # except:
        #    return {"status": 500, "data": {"message": "unable to update the device"}}

    def _mutate_device_settings(self, body, mist_device_settings):
        new_ae_config = {}
        for port in body["port_config"]:
            if port.get("ae_uuid"):
                ae_uuid = port["ae_uuid"]
                port_name = port["port"]
                port_usage = port["new_conf"]
                if not new_ae_config.get(ae_uuid):
                    new_ae_config[ae_uuid] = {
                        "ports": [port_name],
                        "new_conf": port_usage 
                    }
                else:
                    new_ae_config[ae_uuid]["ports"].append(port_name)
            else:
                mist_device_settings = self._unset_port_conf(
                    port, mist_device_settings)
                mist_device_settings = self._set_port_usage(
                    port, mist_device_settings)
                mist_device_settings = self._set_port_conf(
                    port, mist_device_settings)
        if new_ae_config:
            for ae_uuid, ae_config in new_ae_config.items():
                mist_device_settings = self._unset_ae_conf(
                    ae_config, mist_device_settings)
                mist_device_settings = self._set_ae_usage(
                    ae_uuid, ae_config, mist_device_settings)
                mist_device_settings = self._set_ae_conf(
                    ae_uuid, ae_config, mist_device_settings)
        return mist_device_settings

    ## GENERATE AE CONF
    def _set_ae_usage(self, ae_uuid:str, ae_config:dict, mist_device_settings:dict):
        ae_usage_name = f"{PORT_USAGE_NAME_PREFIX}ae-{ae_uuid.split('-')[0]}"
        mist_device_settings["port_usages"][ae_usage_name] = ae_config["new_conf"]
        mist_device_settings["port_usages"][ae_usage_name]["name"] = ae_usage_name
        return mist_device_settings

    def _set_ae_conf(self, ae_uuid:str, ae_config:dict, mist_device_settings:dict):        
        ae_name = ",".join(ae_config["ports"])
        ae_usage_name = f"{PORT_USAGE_NAME_PREFIX}ae-{ae_uuid.split('-')[0]}"
        if not "port_config" in mist_device_settings:
            mist_device_settings["port_config"] = {}
        mist_device_settings["port_config"][ae_name] = {
            "dynamic_usage": None,
            "usage": ae_usage_name,
            "no_local_overwrite": False,
            "aggregated": True
        }
        return mist_device_settings

    def _unset_ae_conf(self, ae_config:dict, mist_device_settings:dict):
        ae_ports = ae_config["ports"]
        for port_name in ae_ports:
            # only useful when there are port configuration at the device level
            if "port_config" in mist_device_settings:
                # if a dedicated entry exists for this switchport, remove it from the config
                if port_name in mist_device_settings["port_config"]:
                    del mist_device_settings["port_config"][port_name]
                # else, need more validation
                else:
                    # split to switchport name to port_type-fpc/pic/slot
                    mso_port_type = port_name.split("-")[0]
                    mso_fpc = port_name.split("-")[1].split("/")[0]
                    mso_pic = port_name.split("-")[1].split("/")[1]
                    mso_slot = port_name.split("-")[1].split("/")[2]
                    # loop on each entry in the configuration
                    for port_config in mist_device_settings["port_config"]:
                        # split the entry if multiple entries (like ge-0/0/0,ge-0/0/1, ...)
                        remaining_ports = []
                        port_config_split = port_config.split(",")
                        for port_config_item in port_config_split:
                            port_config_item = port_config_item.strip()
                            # if single port config (means not ge-0/0/0)
                            if re.match(r'^[a-z]+-[0-9]+/[0-9]+/[0-9]+$', port_config_item):
                                # if not our port, adding it into remaining_ports list
                                if not port_name == port_config_item:
                                    remaining_ports.append(port_config_item)
                            # if not a single port, means it's a port range
                            else:
                                mist_port_type = port_config_item.split("-", 1)[0]
                                mist_fpc = port_config_item.split(
                                    "-", 1)[1].split("/")[0].split("-")
                                mist_pic = port_config_item.split(
                                    "-", 1)[1].split("/")[1].split("-")
                                mist_slot = port_config_item.split(
                                    "-", 1)[1].split("/")[2].split("-")
                                # if our port is included in this port range, generating the remaining port ranges and adding them to the remaining_ports list
                                if mist_port_type == mso_port_type and self._is_in(mso_fpc, mist_fpc) and self._is_in(mso_pic, mist_pic) and self._is_in(mso_slot, mist_slot):
                                    tmp = self._gen_fpc(
                                        mist_port_type, mso_fpc, mso_pic, mso_slot, mist_fpc, mist_pic, mist_slot)
                                    remaining_ports += tmp
                                # otherwise, don't touch it and add the original entry into the remaining_ports list
                                else:
                                    remaining_ports.append(port_config_item)
                        # if port_config not equal to remaining_ports, it means our port was in this entry. replacing the original ports list by the new list
                        remaining_ports = ",".join(remaining_ports)
                        if not port_config == remaining_ports:
                            mist_device_settings["port_config"][remaining_ports] = mist_device_settings["port_config"].pop(
                                port_config)
                            break
        return mist_device_settings
    
    ## GENERATE PORT CONFIG
    def _set_port_usage(self, port, mist_device_settings):
        port_usage_name = f"{PORT_USAGE_NAME_PREFIX}{port['port'].replace('/', '_')}"
        mist_device_settings["port_usages"][port_usage_name] = port["new_conf"]
        mist_device_settings["port_usages"][port_usage_name]["name"] = port_usage_name
        return mist_device_settings

    def _set_port_conf(self, port, mist_device_settings):
        port_name = port["port"]
        port_usage_name = f"{PORT_USAGE_NAME_PREFIX}{port_name.replace('/', '_')}"
        if not "port_config" in mist_device_settings:
            mist_device_settings["port_config"] = {}
        mist_device_settings["port_config"][port_name] = {
            "dynamic_usage": None,
            "usage": port_usage_name,
            "no_local_overwrite": False
        }
        return mist_device_settings

    def _unset_port_conf(self, port, mist_device_settings):
        port_name = port["port"]
        # only useful when there are port configuration at the device level
        if "port_config" in mist_device_settings:
            # if a dedicated entry exists for this switchport, remove it from the config
            if port_name in mist_device_settings["port_config"]:
                del mist_device_settings["port_config"][port_name]
            # else, need more validation
            else:
                # split to switchport name to port_type-fpc/pic/slot
                mso_port_type = port_name.split("-")[0]
                mso_fpc = port_name.split("-")[1].split("/")[0]
                mso_pic = port_name.split("-")[1].split("/")[1]
                mso_slot = port_name.split("-")[1].split("/")[2]
                # loop on each entry in the configuration
                for port_config in mist_device_settings["port_config"]:
                    # split the entry if multiple entries (like ge-0/0/0,ge-0/0/1, ...)
                    remaining_ports = []
                    port_config_split = port_config.split(",")
                    for port_config_item in port_config_split:
                        port_config_item = port_config_item.strip()
                        # if single port config (means not ge-0/0/0)
                        if re.match(r'^[a-z]+-[0-9]+/[0-9]+/[0-9]+$', port_config_item):
                            # if not our port, adding it into remaining_ports list
                            if not port_name == port_config_item:
                                remaining_ports.append(port_config_item)
                        # if not a single port, means it's a port range
                        else:
                            mist_port_type = port_config_item.split("-", 1)[0]
                            mist_fpc = port_config_item.split(
                                "-", 1)[1].split("/")[0].split("-")
                            mist_pic = port_config_item.split(
                                "-", 1)[1].split("/")[1].split("-")
                            mist_slot = port_config_item.split(
                                "-", 1)[1].split("/")[2].split("-")
                            # if our port is included in this port range, generating the remaining port ranges and adding them to the remaining_ports list
                            if mist_port_type == mso_port_type and self._is_in(mso_fpc, mist_fpc) and self._is_in(mso_pic, mist_pic) and self._is_in(mso_slot, mist_slot):
                                tmp = self._gen_fpc(
                                    mist_port_type, mso_fpc, mso_pic, mso_slot, mist_fpc, mist_pic, mist_slot)
                                remaining_ports += tmp
                            # otherwise, don't touch it and add the original entry into the remaining_ports list
                            else:
                                remaining_ports.append(port_config_item)
                    # if port_config not equal to remaining_ports, it means our port was in this entry. replacing the original ports list by the new list
                    remaining_ports = ",".join(remaining_ports)
                    if not port_config == remaining_ports:
                        mist_device_settings["port_config"][remaining_ports] = mist_device_settings["port_config"].pop(
                            port_config)
                        break
        return mist_device_settings

    def _gen_fpc(self, port_type, mso_fpc, mso_pic, mso_slot, mist_fpc, mist_pic, mist_slot):
        ports = []
        data = self._split_index(mist_fpc, mso_fpc)
        if data["a"]:
            ports.append(f"{port_type}-{data['a']}/{mist_pic}/{mist_slot}")
        if data["b"]:
            ports.append(f"{port_type}-{data['b']}/{mist_pic}/{mist_slot}")
        ports += self._gen_pic(port_type, mso_fpc, mso_pic, mso_slot, mist_pic, mist_slot)
        return ports

    def _gen_pic(self, port_type, fpc, mso_pic, mso_slot, mist_pic, mist_slot):
        ports = []
        data = self._split_index(mist_pic, mso_pic)
        if data["a"]:
            ports.append(f"{port_type}-{fpc}/{data['a']}/{mist_slot}")
        if data["b"]:
            ports.append(f"{port_type}-{fpc}/{data['b']}/{mist_slot}")
        ports += self._gen_slot(port_type, fpc, mso_pic, mso_slot, mist_slot)
        return ports

    def _gen_slot(self, port_type, fpc, pic, mso_slot, mist_slot):
        ports = []
        data = self._split_index(mist_slot, mso_slot)
        if data["a"]:
            ports.append(
                f"{port_type}-{fpc}/{pic}/{data['a']}")
        if data["b"]:
            ports.append(
                f"{port_type}-{fpc}/{pic}/{data['b']}")
        return ports

#############
# Get Device Ports Status
#############

    def get_device_ports_status(self, body, retry=False):
        body = self.get_body(body)
        if not "site_id" in body:
            return {"status": 500, "data": {"message": "site_id missing"}}
        if not "device_mac" in body:
            return {"status": 500, "data": {"message": "device_mac missing"}}
        return self._get_device_ports_status(body)

    def _get_device_ports_status(self, body, retry=False):
        extract = self.extractAuth(body)
        device_mac = body["device_mac"]
        try:
            logging.info(f"Device:{device_mac}:Ports Stats: In Process")
            url = f"https://{body['host']}/api/v1/sites/{body['site_id']}/stats/switch_ports/search?mac={device_mac}"
            resp = requests.get(
                url, headers=extract["headers"], cookies=extract["cookies"])
            data = self._process_device_ports_status(resp.json())
            logging.info(f"Device:{device_mac}:Ports Stats: Done")
            return {"status": 200, "data": {"result": data}}
        except:
            if retry:
                logging.error(f"Device:{device_mac}:Ports Stats: Error")
                return {"status": 500, "data": {"message": "unable to retrieve the device ports status"}}
            else:
                logging.warning(f"Device:{device_mac}:Ports Stats: Retry")
                return self._get_device_ports_status(body, True)

    def _process_device_ports_status(self, data):
        portstatus = {}
        if "results" in data:
            for port in data["results"]:
                portstatus[port["port_id"]] = port
        return portstatus


#############
# COMMON
#############


    def _is_in(self, a, b):
        if type(b) == list:
            if len(b) == 1:
                return a == b[0]
            else:
                return b[0] <= a <= b[1]
        else:
            return a == b

    def _split_index(self, entry, index):
        a_list = []
        a = None
        b_list = []
        b = None
        if type(entry) == list and len(entry) > 1:
            # case where our port is the first in the range
            if index == entry[0]:
                a_list.append(int(entry[0]) + 1)
                a_list.append(int(entry[1]))
            # case where our port is the last in the range
            elif index == entry[1]:
                a_list = [int(entry[1]), int(entry[1]) - 1]
            # other cases
            else:
                a_list = [int(entry[0]), int(index) - 1]
                b_list = [int(index) + 1, int(entry[1])]
        if a_list:
            if len(a_list) == 1 or a_list[0] == a_list[1]:
                a = str(a_list[0])
            else:
                a = f"{a_list[0]}-{ a_list[1]}"
        if b_list:
            if len(b_list) == 1 or b_list[0] == b_list[1]:
                b = str(b_list[0])
            else:
                b = f"{b_list[0]}-{b_list[1]}"
        return {"a": a, "b": b}


# Site level
# https://api.mist.com/api/v1/sites/f5fcbee5-fbca-45b3-8bf1-1619ede87879/setting/derived
# Switch level conf
# https://api.mist.com/api/v1/sites/f5fcbee5-fbca-45b3-8bf1-1619ede87879/devices/00000000-0000-0000-1000-2c21311c37b0
# Port status
# https://api.mist.com/api/v1/sites/f5fcbee5-fbca-45b3-8bf1-1619ede87879/wired_clients/search?device_mac=2c21311c37b0&start=1607356196
# Port stats
# https://api.mist.com/api/v1/sites/f5fcbee5-fbca-45b3-8bf1-1619ede87879/stats/switch_ports/search?mac=2c21311c37b0
# {
#     "switch_matching": {
#         "enable": true,
#         "rules": [
#             {
#                 "name": "ex-2300",
#                 "port_config": {
#                     "ge-0/0/10": {
#                         "usage": "lab_sta"
#                     },
#                     "ge-0/0/11": {
#                         "usage": "lab_wan"
#                     },
#                     "xe-0/1/0": {
#                         "usage": "lab_tun"
#                     },
#                     "ge-0/0/0-9": {
#                         "usage": "lab_reg",
#                         "dynamic_usage": "dynamic"
#                     }
#                 },
#                 "additional_config_cmds": [
#                     ""
#                 ],
#                 "match_model[0:6]": "EX2300"
#             }
#         ]
#     },
#     "networks": {
#         "iot": {
#             "vlan_id": "8"
#         }
#     },
#     "port_usages": {
#         "lab_iot": {
#             "name": "lab_iot",
#             "mode": "access",
#             "disabled": false,
#             "port_network": "iot",
#             "stp_edge": true,
#             "all_networks": false,
#             "networks": [],
#             "port_auth": "dot1x",
#             "enable_mac_auth": true,
#             "guest_network": null,
#             "bypass_auth_when_server_down": false
#         },
#         "lab_tun": {
#             "name": "lab_tun",
#             "mode": "trunk",
#             "disabled": false,
#             "port_network": "tun",
#             "stp_edge": false,
#             "all_networks": true,
#             "networks": [],
#             "port_auth": null,
#             "speed": "auto",
#             "duplex": "auto",
#             "mac_limit": 0,
#             "poe_disabled": true
#         },
#         "dynamic": {
#             "mode": "dynamic",
#             "rules": [
#                 {
#                     "src": "radius_dynamicfilter",
#                     "usage": "lab_ap",
#                     "equals": "wireless",
#                     "expression": "[0:8]"
#                 },
#                 {
#                     "src": "radius_dynamicfilter",
#                     "usage": "lab_ap_test",
#                     "equals": "aerohive",
#                     "expression": "[0:8]"
#                 },
#                 {
#                     "src": "link_peermac",
#                     "usage": "lab_wan",
#                     "equals": "90:a2:da",
#                     "expression": "[0:8]"
#                 }
#             ]
#         }
#     },
#     "dynamic": {
#         "mode": "dynamic",
#         "rules": [
#             {
#                 "src": "radius_dynamicfilter",
#                 "usage": "lab_ap",
#                 "equals": "wireless"
#             },
#             {
#                 "src": "radius_dynamicfilter",
#                 "usage": "lab_ap_test",
#                 "equals": "aerohive"
#             }
#         ]
#     },
