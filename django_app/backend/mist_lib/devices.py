
import requests
import logging
import json
import re
from .common import Common
from .ex_models import ex_ref

port_usage_name_prefix = "mso.autogenerated"
logging.basicConfig(level=logging.INFO)


class Devices(Common):

    #############
    # get list of switches on a site
    #############
    def get_devices(self, body):
        body = self.get_body(body)
        if not "site_id" in body:
            return {"status": 500, "data": {"message": "site_id missing"}}
        return self._get_devices(body)

    def _get_devices(self, body, retry=False):
        site_id = body["site_id"]
        try:
            logging.info("Site:{0}:Devices: In Process".format(site_id))
            extract = self.extractAuth(body)
            limit = 1000
            page = 1
            results = []
            total = 1
            while len(results) < int(total) and int(page) < 50:
                device_type = "switch"
                url = "https://{0}/api/v1/sites/{1}/devices?type={2}&limit={3}&page={4}".format(
                    extract["host"], site_id, device_type, limit, page)
                resp = requests.get(
                    url, headers=extract["headers"], cookies=extract["cookies"])
                results.extend(resp.json())
                total = resp.headers["X-Page-Total"]
                page += 1
            logging.info("Site:{0}:Devices: Done".format(site_id))
            return self._get_devices_vc(extract, body["site_id"], results)
        except:
            if retry: 
                logging.error("Site:{0}:Devices: Error".format(site_id))
                return {"status": 500, "data": {"message": "Unable to retrieve the inventory"}}
            else:
                logging.warning("Site:{0}:Devices: Retry".format(site_id))
                return self._get_devices(body, True)

    def _get_devices_vc(self, extract, site_id, devices):
        data = []
        for device in devices:
            device_id = "00000000-0000-0000-1000-{0}".format(device["mac"])
            try:
                logging.info("Device:{0}:VC: In Process".format(site_id))
                url = "https://{0}/api/v1/sites/{1}/devices/{2}/vc".format(
                    extract["host"], site_id, device_id)
                resp = requests.get(
                    url, headers=extract["headers"], cookies=extract["cookies"])
                logging.info("Device:{0}:VC: Done".format(site_id))
                data.append(resp.json())
            except:
                logging.error("Device:{0}:VC: Error".format(site_id))
                #return {"status": 500, "data": {"message": "Unable to retrieve information for device {0}".format(device_id)}}
        return {"status": 200, "data": {"total": len(data), "results": data}}


#############
# Get Device Settings
#############
# body: site_id, device_id, device_name, device_role, device_model


    def get_device_settings(self, body):
        body = self.get_body(body)
        if not "site_id" in body:
            return {"status": 500, "data": {"message": "site_id missing"}}
        if not "device_id" in body:
            return {"status": 500, "data": {"message": "device_id missing"}}
        extract = self.extractAuth(body)
        device_settings = self._get_device_settings(extract, body)
        device_stats = self._get_device_stats(extract, body)
        site_settings = self._get_site_template(extract, body)
        networks = self._generate_networks(site_settings, device_settings)
        if not "status" in device_settings and not "status" in site_settings:
            data = self._generate_device_settings(
                device_settings, site_settings, device_stats)
            return {"status": 200, "data": {"members": data["members"], "networks": networks, "ports": data["ports"], "site": site_settings, "device": device_settings}}

    def _generate_networks(self, site_config, device_config):
        networks = site_config["networks"] if "networks" in site_config else {}
        device_networks = device_config["networks"] if "networks" in device_config else {
        }
        for network in device_networks:
            networks[network] = device_networks[network]
        return networks

    def _get_device_settings(self, extract, body, retry=False):
        device_id = body["device_id"]
        device_config = {
            "networks": {},
            "port_usages": {},
            "port_config": {}
        }
        try:
            logging.info("Device:{0}:Settings: In Process".format(device_id))
            url = "https://{0}/api/v1/sites/{1}/devices/{2}".format(
                body["host"], body["site_id"], device_id)
            resp = requests.get(
                url, headers=extract["headers"], cookies=extract["cookies"])
            device_setting = resp.json()
            device_config["ip_config"] = device_setting["ip_config"] if "ip_config" in device_setting else {}
            device_config["oob_ip_config"] = device_setting["oob_ip_config"] if "oob_ip_config" in device_setting else {}
            device_config["other_ip_configs"] = device_setting["other_ip_configs"] if "other_ip_configs" in device_setting else {}
            device_config["managed"] = device_setting["managed"] if "managed" in device_setting else False
            device_config["networks"] = device_setting["networks"] if "networks" in device_setting else {}
            device_config["port_usages"] = device_setting["port_usages"] if "port_usages" in device_setting else {}
            device_config["port_config"] = device_setting["port_config"] if "port_config" in device_setting else {}
            logging.info("Device:{0}:Settings: Done".format(device_id))
            return device_config
        except:
            if retry:
                logging.error("Device:{0}:Settings: Error".format(device_id))
                return {"status": 500, "data": {"message": "Unable to retrieve the device settings"}}
            else:
                logging.warning("Device:{0}:Settings: Retry".format(device_id))
                return self._get_device_settings(extract, body, True)

    def _get_device_stats(self, extract, body, retry=False):
        device_id = body["device_id"]
        try:
            logging.info("Device:{0}:Stats: In Process".format(device_id))
            url = "https://{0}/api/v1/sites/{1}/stats/devices/{2}".format(
                extract["host"], body["site_id"], device_id)
            resp = requests.get(
                url, headers=extract["headers"], cookies=extract["cookies"])
            logging.info("Device:{0}:Stats: Done".format(device_id))
            return resp.json()
        except:
            if retry:
                logging.error("Device:{0}:Stats: Error".format(device_id))
                return {"status": 500, "data": {"message": "Unable to retrieve information for device {0}".format(body["device_id"])}}
            else:
                logging.warning("Device:{0}:Stats: Retry".format(device_id))
                return self._get_device_stats(extract, body, True)

    def _get_site_template(self, extract, body, retry=False):
        site_id = body["site_id"]
        try:
            logging.info("Site:{0}:Settings: In Process".format(site_id))
            url = "https://{0}/api/v1/sites/{1}/setting/derived".format(
                body["host"], site_id)
            resp = requests.get(
                url, headers=extract["headers"], cookies=extract["cookies"])
            site_setting = resp.json()
            logging.info("Site:{0}:Settings: Done".format(site_id))
            return self._parse_site_template(body, site_setting)
        except:
            if retry:
                logging.error("Site:{0}:Settings: Error".format(site_id))
                return {"status": 500, "data": {"message": "Unable to retrieve the site settings"}}
            else:
                logging.warning("Site:{0}:Settings: Retry".format(site_id))
                return self._get_site_template(extract, body, True)

    def _parse_site_template(self, body, site_setting):
        if "switch_matching" in site_setting:
            device_name = body["device_name"] if "device_name" in body else ""
            device_role = body["device_role"] if "device_role" in body else ""
            device_model = body["device_model"] if "device_model" in body else ""
            site_port_config = {}
            site_networks = {}
            site_port_usages = {}
            if "enable" in site_setting["switch_matching"] and site_setting["switch_matching"]["enable"]:
                rules = site_setting["switch_matching"]["rules"] if "rules" in site_setting["switch_matching"] else {
                }
                site_networks = site_setting["networks"] if "networks" in site_setting else {
                }
                site_port_usages = site_setting["port_usages"] if "port_usages" in site_setting else {
                }

                for rule in rules:
                    match = True
                    for key in rule:
                        if key == "match_model":
                            if not device_model.startswith(rule[key]):
                                match = False
                        if key == "role_name":
                            if not device_role == rule[key]:
                                match = False
                        if key.startswith("match_name"):
                            sub = rule[key].replace(
                                "match_name[", "").replace("]", "").split(":")
                            start = sub[0]
                            end = sub[1]
                            if not device_name[start:end] == rule[key]:
                                match = False
                    if match and "port_config" in rule:
                        site_port_config = rule["port_config"]
                        break
            return {"port_config": site_port_config, "networks": site_networks, "port_usages": site_port_usages}
        else:
            return {"networks": {}, "port_usages": {}, "port_config": {}}

    def _generate_device_settings(self, device_settings, site_settings, device_stats):
        data = {
            "members": [],
            "ports": {}
        }
        fpc = 0
        # Add information about each member of the VC (or the standalone)
        for member in device_stats["module_stat"]:
            tmp = {
                "mac": member["mac"] if "mac" in member else "None",
                "model": member["model"] if "model" in member else "None",
                "serial": member["serial"] if "serial" in member else "None",
                "vc_state": member["vc_state"] if "vc_state" in member else "None",
                "poe": member["poe"] if "poe" in member else "None",
                "fans": member["fans"] if "fans" in member else "None",
                "uptime": member["uptime"] if "uptime" in member else "None",
                "temperatures": member["temperatures"] if "temperatures" in member else "None",
                "vc_links": member["vc_links"] if "vc_links" in member else "None",
                "psus": member["psus"] if "psus" in member else "None",
                "vc_role": member["vs_role"] if "vs_role" in member else "None",
                "ports": [],
                "columns": {
                    "rj45": 0,
                    "sfp": 0
                }
            }

            # Generate the list of ports based on the HW model
            dev = ex_ref[member["model"]]
            for i in range(0, dev["rj45"]):
                tmp["ports"].append("ge-{0}/0/{1}".format(fpc, i))
                data["ports"]["ge-{0}/0/{1}".format(fpc, i)] = {
                    "port": "ge-{0}/0/{1}".format(fpc, i), "site": {}, "device": {}}
            for i in range(0, dev["sfp"]):
                tmp["ports"].append("xe-{0}/1/{1}".format(fpc, i))
                data["ports"]["xe-{0}/1/{1}".format(fpc, i)] = {
                    "port": "xe-{0}/1/{1}".format(fpc, i), "site": {}, "device": {}}
            data["members"].append(tmp)
            fpc += 1
        data = self._translate_mist_conf(data, site_settings, "site")
        data = self._translate_mist_conf(data, device_settings, "device")

        return data

    def _translate_mist_conf(self, data, config, scope):
        if "port_config" in config and config["port_config"]:
            # for each port config (means ge-0/0/0) or ports range config (means ge-0-2/0-1/0-10)
            for port_config in config["port_config"]:
                # if port config (means ge-0/0/0)
                if re.match(r'^[a-z]+-[0-9]+/[0-9]+/[0-9]+$', port_config):
                    fpc = int(port_config.split("-", 1)[1].split("/")[0])
                    if port_config in data["ports"]:
                        data["ports"][port_config][scope] = config["port_config"][port_config]
                    else:
                        data["ports"][port_config] = {
                            "port": port_config, "site": {}, "device": {}}
                        data["ports"][port_config][scope] = config["port_config"][port_config]

                # else, it's a ports range config (means ge-0-1/0-2/0-10)
                else:
                    port_config_split = port_config.split(",")
                    for port_config_item in port_config_split:
                        port_type = port_config_item.split("-", 1)[0]
                        fpc = port_config_item.split(
                            "-", 1)[1].split("/")[0].split("-")
                        pic = port_config_item.split(
                            "-", 1)[1].split("/")[1].split("-")
                        slot = port_config_item.split(
                            "-", 1)[1].split("/")[2].split("-")
                        for i in range(int(fpc[0]), int(fpc[-1])+1):
                            for j in range(int(pic[0]), int(pic[-1])+1):
                                for k in range(int(slot[0]), int(slot[-1])+1):
                                    interface = "{0}-{1}/{2}/{3}".format(
                                        port_type, i, j, k)
                                    if interface in data["ports"]:
                                        data["ports"][interface][scope] = config["port_config"][port_config]
                                    else:
                                        data["ports"][interface] = {
                                            "port": interface, "site": {}, "device": {}}
                                        data["ports"][interface][scope] = config["port_config"][port_config]
        return data

    #############
    # Update Device Settings
    #############
    def update_device_settings(self, body):
        body = self.get_body(body)
        if not "site_id" in body:
            return {"status": 500, "data": {"message": "site_id missing"}}
        if not "device_id" in body:
            return {"status": 500, "data": {"message": "device_id missing"}}
        if not "port_config" in body:
            return {"status": 500, "data": {"message": "port_config missing"}}
        return self._update_device_settings(body)

    def _update_device_settings(self, body):
        extract = self.extractAuth(body)
        # try:
        url = "https://{0}/api/v1/sites/{1}/devices/{2}".format(
            body["host"], body["site_id"], body["device_id"])
        resp = requests.get(
            url, headers=extract["headers"], cookies=extract["cookies"])
        mist_device_settings = self._mutate_device_settings(body, resp.json())
        resp = requests.put(
            url, headers=extract["headers"], cookies=extract["cookies"], json=mist_device_settings)
        resp = resp.json()

        return {"status": 200, "data": {"result": resp}}
        # except:
        #    return {"status": 500, "data": {"message": "unable to update the device"}}

    def _mutate_device_settings(self, body, mist_device_settings):
        for port in body["port_config"]:
            mist_device_settings = self._unset_port_conf(
                port, mist_device_settings)
            mist_device_settings = self._set_port_usage(
                port, mist_device_settings)
            mist_device_settings = self._set_port_conf(
                port, mist_device_settings)
        return mist_device_settings

    def _set_port_usage(self, port, mist_device_settings):
        port_usage_name = "{0}.{1}".format(
            port_usage_name_prefix, port["port"].replace("/", "_"))
        mist_device_settings["port_usages"][port_usage_name] = port["new_conf"]
        mist_device_settings["port_usages"][port_usage_name]["name"] = port_usage_name
        return mist_device_settings

    def _set_port_conf(self, port, mist_device_settings):
        port_name = port["port"]
        port_usage_name = "{0}.{1}".format(
            port_usage_name_prefix, port_name.replace("/", "_"))
        if not "port_config" in mist_device_settings:
            mist_device_settings["port_config"] = {}
        mist_device_settings["port_config"][port_name] = {
            "dynamic_usage": None,
            "usage": port_usage_name
        }
        return mist_device_settings

    def _unset_port_conf(self, port, mist_device_settings):
        port_name = port["port"]
        # only useful when there are port configuration at the device level
        if "port_config" in mist_device_settings:
            # if a dedicated entry exists for this switchport, remove it from the config
            if port_name in mist_device_settings["port_config"]:
                del mist_device_settings["port_config"][port_name]
            # else, need more validation
            else:
                # split to switchport name to port_type-fpc/pic/slot
                mso_port_type = port_name.split("-")[0]
                mso_fpc = port_name.split("-")[1].split("/")[0]
                mso_pic = port_name.split("-")[1].split("/")[1]
                mso_slot = port_name.split("-")[1].split("/")[2]
                # loop on each entry in the configuration
                for port_config in mist_device_settings["port_config"]:
                    # split the entry if multiple entries (like ge-0/0/0,ge-0/0/1, ...)
                    remaining_ports = []
                    port_config_split = port_config.split(",")
                    for port_config_item in port_config_split:
                        port_config_item = port_config_item.strip()
                        # if single port config (means not ge-0/0/0)
                        if re.match(r'^[a-z]+-[0-9]+/[0-9]+/[0-9]+$', port_config_item):
                            # if not our port, adding it into remaining_ports list
                            if not port_name == port_config_item:
                                remaining_ports.append(port_config_item)
                        # if not a single port, means it's a port range
                        else:
                            mist_port_type = port_config_item.split("-", 1)[0]
                            mist_fpc = port_config_item.split(
                                "-", 1)[1].split("/")[0].split("-")
                            mist_pic = port_config_item.split(
                                "-", 1)[1].split("/")[1].split("-")
                            mist_slot = port_config_item.split(
                                "-", 1)[1].split("/")[2].split("-")
                            # if our port is included in this port range, generating the remaining port ranges and adding them to the remaining_ports list
                            if mist_port_type == mso_port_type and self._is_in(mso_fpc, mist_fpc) and self._is_in(mso_pic, mist_pic) and self._is_in(mso_slot, mist_slot):
                                tmp = self._gen_fpc(
                                    mist_port_type, mso_fpc, mso_pic, mso_slot, mist_fpc, mist_pic, mist_slot)
                                remaining_ports += tmp
                            # otherwise, don't touch it and add the original entry into the remaining_ports list
                            else:
                                remaining_ports.append(port_config_item)
                    # if port_config not equal to remaining_ports, it means our port was in this entry. replacing the original ports list by the new list
                    remaining_ports = ",".join(remaining_ports)
                    if not port_config == remaining_ports:
                        mist_device_settings["port_config"][remaining_ports] = mist_device_settings["port_config"].pop(
                            port_config)
                        break
        return mist_device_settings

    def _gen_fpc(self, port_type, mso_fpc, mso_pic, mso_slot, mist_fpc, mist_pic, mist_slot):
        ports = []
        data = self._split_index(mist_fpc, mso_fpc)
        if data["a"]:
            ports.append("{0}-{1}/{2}/{3}".format(port_type, data["a"], mist_pic, mist_slot))
        if data["b"]:
            ports.append("{0}-{1}/{2}/{3}".format(port_type, data["b"], mist_pic, mist_slot))
        ports += self._gen_pic(port_type, mso_fpc, mso_pic, mso_slot, mist_pic, mist_slot)
        return ports

    def _gen_pic(self, port_type, fpc, mso_pic, mso_slot, mist_pic, mist_slot):
        ports = []
        data = self._split_index(mist_pic, mso_pic)
        if data["a"]:
            ports.append("{0}-{1}/{2}/{3}".format(port_type, fpc, data["a"], mist_slot))
        if data["b"]:
            ports.append("{0}-{1}/{2}/{3}".format(port_type, fpc, data["b"], mist_slot))
        ports += self._gen_slot(port_type, fpc, mso_pic, mso_slot, mist_slot)
        return ports

    def _gen_slot(self, port_type, fpc, pic, mso_slot, mist_slot):
        ports = []
        data = self._split_index(mist_slot, mso_slot)
        if data["a"]:
            ports.append(
                "{0}-{1}/{2}/{3}".format(port_type, fpc, pic, data["a"]))
        if data["b"]:
            ports.append(
                "{0}-{1}/{2}/{3}".format(port_type, fpc, pic, data["b"]))
        return ports

#############
# Get Device Ports Status
#############

    def get_device_ports_status(self, body, retry=False):
        body = self.get_body(body)
        if not "site_id" in body:
            return {"status": 500, "data": {"message": "site_id missing"}}
        if not "device_mac" in body:
            return {"status": 500, "data": {"message": "device_mac missing"}}
        return self._get_device_ports_status(body)

    def _get_device_ports_status(self, body, retry=False):
        extract = self.extractAuth(body)
        device_mac = body["device_mac"]
        try:
            logging.info("Device:{0}:Ports Stats: In Process".format(device_mac))
            url = "https://{0}/api/v1/sites/{1}/stats/switch_ports/search?mac={2}".format(
                body["host"], body["site_id"], device_mac)
            resp = requests.get(
                url, headers=extract["headers"], cookies=extract["cookies"])
            data = self._process_device_ports_status(resp.json())
            logging.info("Device:{0}:Ports Stats: Done".format(device_mac))
            return {"status": 200, "data": {"result": data}}
        except:
            if retry:
                logging.error("Device:{0}:Ports Stats: Error".format(device_mac))
                return {"status": 500, "data": {"message": "unable to retrieve the device ports status"}}
            else:
                logging.warning("Device:{0}:Ports Stats: Retry".format(device_mac))
                return self._get_device_ports_status(body, True)

    def _process_device_ports_status(self, data):
        portstatus = {}
        if "results" in data:
            for port in data["results"]:
                portstatus[port["port_id"]] = port
        return portstatus


#############
# COMMON
#############


    def _is_in(self, a, b):
        if type(b) == list:
            if len(b) == 1:
                return a == b[0]
            else:
                return b[0] <= a <= b[1]
        else:
            return a == b

    def _split_index(self, entry, index):
        a_list = []
        a = None
        b_list = []
        b = None
        if type(entry) == list and len(entry) > 1:
            # case where our port is the first in the range
            if index == entry[0]:
                a_list.append(int(entry[0]) + 1)
                a_list.append(int(entry[1]))
            # case where our port is the last in the range
            elif index == entry[1]:
                a_list = [int(entry[1]), int(entry[1]) - 1]
            # other cases
            else:
                a_list = [int(entry[0]), int(index) - 1]
                b_list = [int(index) + 1, int(entry[1])]
        if a_list:
            if len(a_list) == 1 or a_list[0] == a_list[1]:
                a = str(a_list[0])
            else:
                a = "{0}-{1}".format(a_list[0], a_list[1])
        if b_list:
            if len(b_list) == 1 or b_list[0] == b_list[1]:
                b = str(b_list[0])
            else:
                b = "{0}-{1}".format(b_list[0], b_list[1])
        return {"a": a, "b": b}


# Site level
# https://api.mist.com/api/v1/sites/f5fcbee5-fbca-45b3-8bf1-1619ede87879/setting/derived
# Switch level conf
# https://api.mist.com/api/v1/sites/f5fcbee5-fbca-45b3-8bf1-1619ede87879/devices/00000000-0000-0000-1000-2c21311c37b0
# Port status
# https://api.mist.com/api/v1/sites/f5fcbee5-fbca-45b3-8bf1-1619ede87879/wired_clients/search?device_mac=2c21311c37b0&start=1607356196
# Port stats
# https://api.mist.com/api/v1/sites/f5fcbee5-fbca-45b3-8bf1-1619ede87879/stats/switch_ports/search?mac=2c21311c37b0
# {
#     "switch_matching": {
#         "enable": true,
#         "rules": [
#             {
#                 "name": "ex-2300",
#                 "port_config": {
#                     "ge-0/0/10": {
#                         "usage": "lab_sta"
#                     },
#                     "ge-0/0/11": {
#                         "usage": "lab_wan"
#                     },
#                     "xe-0/1/0": {
#                         "usage": "lab_tun"
#                     },
#                     "ge-0/0/0-9": {
#                         "usage": "lab_reg",
#                         "dynamic_usage": "dynamic"
#                     }
#                 },
#                 "additional_config_cmds": [
#                     ""
#                 ],
#                 "match_model[0:6]": "EX2300"
#             }
#         ]
#     },
#     "networks": {
#         "iot": {
#             "vlan_id": "8"
#         }
#     },
#     "port_usages": {
#         "lab_iot": {
#             "name": "lab_iot",
#             "mode": "access",
#             "disabled": false,
#             "port_network": "iot",
#             "stp_edge": true,
#             "all_networks": false,
#             "networks": [],
#             "port_auth": "dot1x",
#             "enable_mac_auth": true,
#             "guest_network": null,
#             "bypass_auth_when_server_down": false
#         },
#         "lab_tun": {
#             "name": "lab_tun",
#             "mode": "trunk",
#             "disabled": false,
#             "port_network": "tun",
#             "stp_edge": false,
#             "all_networks": true,
#             "networks": [],
#             "port_auth": null,
#             "speed": "auto",
#             "duplex": "auto",
#             "mac_limit": 0,
#             "poe_disabled": true
#         },
#         "dynamic": {
#             "mode": "dynamic",
#             "rules": [
#                 {
#                     "src": "radius_dynamicfilter",
#                     "usage": "lab_ap",
#                     "equals": "wireless",
#                     "expression": "[0:8]"
#                 },
#                 {
#                     "src": "radius_dynamicfilter",
#                     "usage": "lab_ap_test",
#                     "equals": "aerohive",
#                     "expression": "[0:8]"
#                 },
#                 {
#                     "src": "link_peermac",
#                     "usage": "lab_wan",
#                     "equals": "90:a2:da",
#                     "expression": "[0:8]"
#                 }
#             ]
#         }
#     },
#     "dynamic": {
#         "mode": "dynamic",
#         "rules": [
#             {
#                 "src": "radius_dynamicfilter",
#                 "usage": "lab_ap",
#                 "equals": "wireless"
#             },
#             {
#                 "src": "radius_dynamicfilter",
#                 "usage": "lab_ap_test",
#                 "equals": "aerohive"
#             }
#         ]
#     },
